# uvx --from datamodel-code-generator datamodel-codegen --input schema_config.json --input-file-type jsonschema --output model_config.py --output-model-type pydantic_v2.BaseModel --use-annotated
# generated by datamodel-codegen:
#   filename:  schema_config.json
#   timestamp: 2025-08-29T06:30:04+00:00

from __future__ import annotations

from typing import Annotated, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel


class ContextPhase1(BaseModel):
    chance: Annotated[float, Field(description='A chance defined by probability.')]
    type: Literal['initial']


class ContextPhase2(BaseModel):
    chance: Annotated[float, Field(description='A chance defined by probability.')]
    type: Literal['exploration']


class ContextPhase3(BaseModel):
    chance: Annotated[float, Field(description='A chance defined by probability.')]
    type: Literal['exploitation']


class ContextPhase(RootModel[Union[ContextPhase1, ContextPhase2, ContextPhase3]]):
    root: Annotated[
        Union[ContextPhase1, ContextPhase2, ContextPhase3],
        Field(description='A selection phase filter for `MutationProbabilityType`.'),
    ]


class ContextThreshold(BaseModel):
    jobs: Annotated[int, Field(description='Min amount of jobs in individual.', ge=0)]
    routes: Annotated[
        int, Field(description='Min amount of routes in individual.', ge=0)
    ]


class HyperType2(BaseModel):
    type: Literal['dynamic-selective']


class LocalOperatorType1(BaseModel):
    type: Literal['swap-star']
    weight: Annotated[int, Field(ge=0)]


class LocalOperatorType5(BaseModel):
    type: Literal['sequence']
    weight: Annotated[int, Field(ge=0)]


class LoggingConfig(BaseModel):
    enabled: Annotated[
        bool,
        Field(description='Specifies whether logging is enabled. Default is false.'),
    ]
    prefix: Annotated[
        Optional[str], Field(description='Prefix of logging messages.')
    ] = None


class MetricsConfig(BaseModel):
    enabled: Annotated[
        bool,
        Field(
            description='Specifies whether metrics collection is enabled. Default is false.'
        ),
    ]
    trackPopulation: Annotated[
        Optional[int],
        Field(
            description='Specifies how often population is tracked. Default is 1000 (generations).',
            ge=0,
        ),
    ] = None


class MinMaxConfig(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]


class NoiseConfig(BaseModel):
    max: float
    min: float
    probability: float


class OperatorProbabilityType1(BaseModel):
    scalar: Annotated[float, Field(description='Probability value of the operator.')]


class OperatorProbabilityType2(BaseModel):
    phases: Annotated[
        List[ContextPhase], Field(description='Selection phase specific parameters.')
    ]
    threshold: Annotated[ContextThreshold, Field(description='Threshold parameters.')]


class OperatorProbabilityType(
    RootModel[Union[OperatorProbabilityType1, OperatorProbabilityType2]]
):
    root: Annotated[
        Union[OperatorProbabilityType1, OperatorProbabilityType2],
        Field(description='A operator probability type'),
    ]


class OutputConfig(BaseModel):
    includeGeojson: Annotated[
        Optional[bool],
        Field(
            description='True if the solution, serialized as geojson features, should be included in solution.extras.'
        ),
    ] = None


class ParallelismConfig(BaseModel):
    numThreadPools: Annotated[int, Field(description='Number of thread pools.', ge=0)]
    threadsPerPool: Annotated[
        int, Field(description='Specifies amount of threads in each thread pool.', ge=0)
    ]


class PopulationType1(BaseModel):
    selectionSize: Annotated[
        Optional[int],
        Field(description='Selection size. Default is number of cpus.', ge=0),
    ] = None
    type: Literal['greedy']


class PopulationType2(BaseModel):
    maxSize: Annotated[
        Optional[int], Field(description='Max population size. Default is 4.', ge=0)
    ] = None
    selectionSize: Annotated[
        Optional[int],
        Field(description='Selection size. Default is number of cpus.', ge=0),
    ] = None
    type: Literal['elitism']


class PopulationType3(BaseModel):
    distributionFactor: Annotated[
        Optional[float], Field(description='Distribution factor. Default is 0.75.')
    ] = None
    explorationRatio: Annotated[
        Optional[float],
        Field(description='An exploration phase ratio. Default is 0.9.'),
    ] = None
    maxEliteSize: Annotated[
        Optional[int], Field(description='Elite population size. Default is 2.', ge=0)
    ] = None
    maxNodeSize: Annotated[
        Optional[int], Field(description='Node population size. Default is 4.', ge=0)
    ] = None
    rebalanceMemory: Annotated[
        Optional[int], Field(description='A rebalance memory. Default is 100.', ge=0)
    ] = None
    selectionSize: Annotated[
        Optional[int],
        Field(description='Selection size. Default is number of cpus.', ge=0),
    ] = None
    spreadFactor: Annotated[
        Optional[float], Field(description='Spread factor. Default is 0.75.')
    ] = None
    type: Literal['rosomaxa']


class PopulationType(
    RootModel[Union[PopulationType1, PopulationType2, PopulationType3]]
):
    root: Union[PopulationType1, PopulationType2, PopulationType3]


class ProgressConfig(BaseModel):
    enabled: Annotated[
        bool,
        Field(description='Specifies whether logging is enabled. Default is false.'),
    ]
    logBest: Annotated[
        Optional[int],
        Field(
            description='Specifies how often best individual is logged. Default is 100 (generations).',
            ge=0,
        ),
    ] = None
    logPopulation: Annotated[
        Optional[int],
        Field(
            description='Specifies how often population is logged. Default is 1000 (generations).',
            ge=0,
        ),
    ] = None


class RecreateMethod1(BaseModel):
    type: Literal['cheapest']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod2(BaseModel):
    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal['skip-best']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod3(BaseModel):
    type: Literal['blinks']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod4(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    type: Literal['gaps']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod5(BaseModel):
    type: Literal['nearest']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod6(BaseModel):
    type: Literal['skip-random']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod7(BaseModel):
    type: Literal['slice']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod8(BaseModel):
    type: Literal['farthest']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod9(BaseModel):
    max: float
    min: float
    probability: float
    type: Literal['perturbation']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod10(BaseModel):
    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal['regret']
    weight: Annotated[int, Field(ge=0)]


class RecreateMethod(
    RootModel[
        Union[
            RecreateMethod1,
            RecreateMethod2,
            RecreateMethod3,
            RecreateMethod4,
            RecreateMethod5,
            RecreateMethod6,
            RecreateMethod7,
            RecreateMethod8,
            RecreateMethod9,
            RecreateMethod10,
        ]
    ]
):
    root: Annotated[
        Union[
            RecreateMethod1,
            RecreateMethod2,
            RecreateMethod3,
            RecreateMethod4,
            RecreateMethod5,
            RecreateMethod6,
            RecreateMethod7,
            RecreateMethod8,
            RecreateMethod9,
            RecreateMethod10,
        ],
        Field(
            description='Specifies recreate methods with their probability weight and specific parameters.'
        ),
    ]


class RuinMethod1(BaseModel):
    alpha: float
    cavg: Annotated[int, Field(ge=0)]
    lmax: Annotated[int, Field(ge=0)]
    probability: float
    type: Literal['adjusted-string']


class RuinMethod2(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    probability: float
    type: Literal['neighbour']


class RuinMethod3(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    probability: float
    type: Literal['random-job']


class RuinMethod4(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    probability: float
    type: Literal['random-route']


class RuinMethod5(BaseModel):
    probability: float
    type: Literal['close-route']


class RuinMethod6(BaseModel):
    probability: float
    type: Literal['worst-route']


class RuinMethod7(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    probability: float
    skip: Annotated[int, Field(ge=0)]
    type: Literal['worst-job']


class RuinMethod8(BaseModel):
    max: Annotated[int, Field(ge=0)]
    min: Annotated[int, Field(ge=0)]
    probability: float
    type: Literal['cluster']


class RuinMethod(
    RootModel[
        Union[
            RuinMethod1,
            RuinMethod2,
            RuinMethod3,
            RuinMethod4,
            RuinMethod5,
            RuinMethod6,
            RuinMethod7,
            RuinMethod8,
        ]
    ]
):
    root: Annotated[
        Union[
            RuinMethod1,
            RuinMethod2,
            RuinMethod3,
            RuinMethod4,
            RuinMethod5,
            RuinMethod6,
            RuinMethod7,
            RuinMethod8,
        ],
        Field(
            description='Specifies ruin methods with their probability weight and specific parameters.'
        ),
    ]


class SearchOperatorType1(BaseModel):
    probability: Annotated[
        OperatorProbabilityType, Field(description='Probability of operator.')
    ]
    repeat: Annotated[
        int, Field(description='Amount of attempts to repeat refinement.', ge=0)
    ]
    routes: Annotated[
        MinMaxConfig,
        Field(description='Max routes to be selected in decomposed solution.'),
    ]
    type: Literal['decomposition']


class TelemetryConfig(BaseModel):
    metrics: Optional[MetricsConfig] = None
    progress: Optional[ProgressConfig] = None


class VariationConfig(BaseModel):
    cv: float
    intervalType: str
    isGlobal: bool
    value: Annotated[int, Field(ge=0)]


class EnvironmentConfig(BaseModel):
    isExperimental: Annotated[
        Optional[bool], Field(description='Specifies experimental behavior flag.')
    ] = None
    logging: Annotated[
        Optional[LoggingConfig], Field(description='Specifies a logging configuration.')
    ] = None
    parallelism: Annotated[
        Optional[ParallelismConfig],
        Field(description='Specifies a data parallelism configuration.'),
    ] = None


class InitialAlternativesConfig(BaseModel):
    maxSize: Annotated[int, Field(ge=0)]
    methods: List[RecreateMethod]
    quota: float


class InitialConfig(BaseModel):
    alternatives: InitialAlternativesConfig
    method: RecreateMethod


class LocalOperatorType2(BaseModel):
    noise: NoiseConfig
    type: Literal['inter-route-best']
    weight: Annotated[int, Field(ge=0)]


class LocalOperatorType3(BaseModel):
    noise: NoiseConfig
    type: Literal['inter-route-random']
    weight: Annotated[int, Field(ge=0)]


class LocalOperatorType4(BaseModel):
    noise: NoiseConfig
    type: Literal['intra-route-random']
    weight: Annotated[int, Field(ge=0)]


class LocalOperatorType(
    RootModel[
        Union[
            LocalOperatorType1,
            LocalOperatorType2,
            LocalOperatorType3,
            LocalOperatorType4,
            LocalOperatorType5,
        ]
    ]
):
    root: Annotated[
        Union[
            LocalOperatorType1,
            LocalOperatorType2,
            LocalOperatorType3,
            LocalOperatorType4,
            LocalOperatorType5,
        ],
        Field(description='A local search configuration.'),
    ]


class RuinGroupConfig(BaseModel):
    methods: Annotated[List[RuinMethod], Field(description='Ruin methods.')]
    weight: Annotated[int, Field(description='Weight of the group.', ge=0)]


class SearchOperatorType2(BaseModel):
    operators: Annotated[
        List[LocalOperatorType], Field(description='Local search operator.')
    ]
    probability: Annotated[
        OperatorProbabilityType, Field(description='Probability of operator.')
    ]
    times: Annotated[
        MinMaxConfig, Field(description='Amount of times one of operators is applied.')
    ]
    type: Literal['local-search']


class SearchOperatorType3(BaseModel):
    probability: Annotated[OperatorProbabilityType, Field(description='Probability.')]
    recreates: Annotated[List[RecreateMethod], Field(description='Recreate methods.')]
    ruins: Annotated[List[RuinGroupConfig], Field(description='Ruin methods.')]
    type: Literal['ruin-recreate']


class SearchOperatorType(
    RootModel[Union[SearchOperatorType1, SearchOperatorType2, SearchOperatorType3]]
):
    root: Annotated[
        Union[SearchOperatorType1, SearchOperatorType2, SearchOperatorType3],
        Field(description='A operator configuration.'),
    ]


class TerminationConfig(BaseModel):
    maxGenerations: Annotated[Optional[int], Field(ge=0)] = None
    maxTime: Annotated[Optional[int], Field(ge=0)] = None
    variation: Optional[VariationConfig] = None


class EvolutionConfig(BaseModel):
    initial: Optional[InitialConfig] = None
    population: Optional[PopulationType] = None


class HyperType1(BaseModel):
    operators: Annotated[
        Optional[List[SearchOperatorType]],
        Field(description='A collection of inner operators (metaheuristics).'),
    ] = None
    type: Literal['static-selective']


class HyperType(RootModel[Union[HyperType1, HyperType2]]):
    root: Annotated[
        Union[HyperType1, HyperType2],
        Field(description='A hyper heuristic configuration.'),
    ]


class Config(BaseModel):
    environment: Annotated[
        Optional[EnvironmentConfig],
        Field(description='Specifies environment configuration.'),
    ] = None
    evolution: Annotated[
        Optional[EvolutionConfig],
        Field(description='Specifies evolution configuration.'),
    ] = None
    hyper: Annotated[
        Optional[HyperType], Field(description='Specifies hyper heuristic type.')
    ] = None
    output: Annotated[
        Optional[OutputConfig], Field(description='Specifies output configuration.')
    ] = None
    telemetry: Annotated[
        Optional[TelemetryConfig],
        Field(description='Specifies telemetry configuration.'),
    ] = None
    termination: Annotated[
        Optional[TerminationConfig],
        Field(description='Specifies algorithm termination configuration.'),
    ] = None
