# uvx --from datamodel-code-generator datamodel-codegen --input schema_problem.json --input-file-type jsonschema --output model_problem.py --output-model-type pydantic_v2.BaseModel --use-annotated
# generated by datamodel-codegen:
#   filename:  schema_problem.json
#   timestamp: 2025-08-29T06:31:57+00:00

from __future__ import annotations

from typing import Annotated, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel


class CustomLocationType(RootModel[str]):
    root: Annotated[
        str,
        Field(description='A custom location type which has no reference to matrix.'),
    ]


class JobSkills(BaseModel):
    allOf: Annotated[
        Optional[List[str]],
        Field(description='Vehicle should have all of these skills defined.'),
    ] = None
    noneOf: Annotated[
        Optional[List[str]],
        Field(description='Vehicle should have none of these skills defined.'),
    ] = None
    oneOf: Annotated[
        Optional[List[str]],
        Field(description='Vehicle should have at least one of these skills defined.'),
    ] = None


class Location1(BaseModel):
    lat: Annotated[float, Field(description='Latitude.')]
    lng: Annotated[float, Field(description='Longitude.')]


class Location2(BaseModel):
    index: Annotated[int, Field(description='An index in routing matrix.', ge=0)]


class Location3(BaseModel):
    type: Annotated[
        CustomLocationType, Field(description='Specifies a custom location type.')
    ]


class Location(RootModel[Union[Location1, Location2, Location3]]):
    root: Annotated[
        Union[Location1, Location2, Location3],
        Field(description='Represents a location type.'),
    ]


class MatrixProfile(BaseModel):
    name: Annotated[str, Field(description='Profile name.')]
    speed: Annotated[
        Optional[float],
        Field(
            description='Approximation speed (meters per second). Used only when routing matrix is not specified.\nDefault value is 10.'
        ),
    ] = None


class MultiStrategy1(BaseModel):
    name: Literal['sum']


class MultiStrategy2(BaseModel):
    name: Literal['weighted-sum']
    weights: Annotated[
        List[float],
        Field(
            description='Individual weights. Size of vector must be the same as amount of objective functions.'
        ),
    ]


class MultiStrategy(RootModel[Union[MultiStrategy1, MultiStrategy2]]):
    root: Annotated[
        Union[MultiStrategy1, MultiStrategy2],
        Field(
            description='An mupltiple objective strategy type specifies how competitive objective functions are compared\namong each other.'
        ),
    ]


class Objective1(BaseModel):
    type: Literal['minimize-cost']


class Objective2(BaseModel):
    type: Literal['minimize-distance']


class Objective3(BaseModel):
    type: Literal['minimize-duration']


class Objective4(BaseModel):
    type: Literal['minimize-tours']


class Objective5(BaseModel):
    type: Literal['maximize-tours']


class Objective6(BaseModel):
    breaks: Annotated[
        Optional[float], Field(description='Specifies a weight of skipped breaks.')
    ] = None
    type: Literal['maximize-value']


class Objective7(BaseModel):
    breaks: Annotated[
        Optional[float],
        Field(
            description='A skipped break weight to increase/decrease break is importance.\nDefault is 1.'
        ),
    ] = None
    type: Literal['minimize-unassigned']


class Objective8(BaseModel):
    type: Literal['minimize-arrival-time']


class Objective9(BaseModel):
    type: Literal['balance-max-load']


class Objective10(BaseModel):
    type: Literal['balance-activities']


class Objective11(BaseModel):
    type: Literal['balance-distance']


class Objective12(BaseModel):
    type: Literal['balance-duration']


class Objective13(BaseModel):
    job_radius: Annotated[
        int, Field(description='Specifies radius of neighbourhood. Min is 1.', ge=0)
    ]
    type: Literal['compact-tour']


class Objective14(BaseModel):
    type: Literal['tour-order']


class Objective15(BaseModel):
    type: Literal['fast-service']


class Objective16(BaseModel):
    levels: Annotated[
        int, Field(description='Number of levels in area hierarchy.', ge=0)
    ]
    type: Literal['hierarchical-areas']


class RelationType(RootModel[str]):
    root: Annotated[str, Field(description='Relation type.')]


class ShiftEnd(BaseModel):
    earliest: Annotated[
        Optional[str],
        Field(
            description='Earliest possible arrival date time in RFC3339 format.\nAt the moment, not supported, reserved for future.'
        ),
    ] = None
    latest: Annotated[
        str, Field(description='Latest possible arrival date time in RFC3339 format.')
    ]
    location: Annotated[Location, Field(description='Shift end location.')]


class ShiftStart(BaseModel):
    earliest: Annotated[
        str,
        Field(description='Earliest possible departure date time in RFC3339 format.'),
    ]
    latest: Annotated[
        Optional[str],
        Field(
            description='Latest possible departure date time in RFC3339 format. If omitted, departure time\ntheoretically can be shifted till arrival. Set this value, if you want to limit\ndeparture time optimization.'
        ),
    ] = None
    location: Annotated[Location, Field(description='Shift start location.')]


class VehicleCosts(BaseModel):
    distance: Annotated[float, Field(description='Cost per distance unit.')]
    fixed: Annotated[
        Optional[float], Field(description='Fixed is cost of vehicle usage per tour.')
    ] = None
    time: Annotated[float, Field(description='Cost per time unit.')]


class VehicleLimits(BaseModel):
    maxDistance: Annotated[
        Optional[float],
        Field(
            description='Max traveling distance per shift/tour.\nNo distance restrictions when omitted.'
        ),
    ] = None
    maxDuration: Annotated[
        Optional[float],
        Field(description='Max duration per tour.\nNo time restrictions when omitted.'),
    ] = None
    tourSize: Annotated[
        Optional[int],
        Field(
            description='Max amount job activities.\nNo job activities restrictions when omitted.',
            ge=0,
        ),
    ] = None


class VehicleOptionalBreakPlace(BaseModel):
    duration: Annotated[float, Field(description='Break duration.')]
    location: Annotated[Optional[Location], Field(description='Break location.')] = None
    tag: Annotated[
        Optional[str],
        Field(
            description='A tag which will be propagated back within corresponding activity in solution.'
        ),
    ] = None


class VehicleOptionalBreakPolicy(RootModel[str]):
    root: Annotated[str, Field(description='Vehicle break policy.')]


class VehicleOptionalBreakTime(RootModel[Union[List[str], List[float]]]):
    root: Annotated[
        Union[List[str], List[float]],
        Field(description='Vehicle optional break time variant.'),
    ]


class VehicleProfile(BaseModel):
    matrix: Annotated[str, Field(description='Routing matrix profile name.')]
    scale: Annotated[
        Optional[float],
        Field(description='Traveling duration scale factor.\nDefault value is 1.'),
    ] = None


class VehicleReload(BaseModel):
    duration: Annotated[
        float, Field(description='A total loading/reloading duration (service time).')
    ]
    location: Annotated[Location, Field(description='A place location.')]
    resourceId: Annotated[
        Optional[str], Field(description='A shared reload resource id.')
    ] = None
    tag: Annotated[
        Optional[str],
        Field(
            description='A tag which will be propagated back within corresponding activity in solution.'
        ),
    ] = None
    times: Annotated[
        Optional[List[List[str]]],
        Field(
            description='A list of time windows with time specified in RFC3339 format.'
        ),
    ] = None


class VehicleRequiredBreakTime1(BaseModel):
    earliest: Annotated[str, Field(description='Start of the range.')]
    latest: Annotated[str, Field(description='End of the range.')]


class VehicleRequiredBreakTime2(BaseModel):
    earliest: Annotated[float, Field(description='Start of the range.')]
    latest: Annotated[float, Field(description='End of the range.')]


class VehicleRequiredBreakTime(
    RootModel[Union[VehicleRequiredBreakTime1, VehicleRequiredBreakTime2]]
):
    root: Annotated[
        Union[VehicleRequiredBreakTime1, VehicleRequiredBreakTime2],
        Field(description='Vehicle required break time variant.'),
    ]


class VehicleResource1(BaseModel):
    capacity: Annotated[List[int], Field(description='A total resource capacity.')]
    id: Annotated[str, Field(description='Resource id.')]
    type: Literal['reload']


class VehicleResource(RootModel[VehicleResource1]):
    root: Annotated[
        VehicleResource1, Field(description='Specifies vehicle resource type.')
    ]


class VicinityFilteringPolicy(BaseModel):
    excludeJobIds: Annotated[
        List[str],
        Field(description='Ids of the jobs which cannot be used within clustering.'),
    ]


class VicinityServingPolicy1(BaseModel):
    parking: Annotated[float, Field(description='Parking time.')]
    type: Literal['original']


class VicinityServingPolicy2(BaseModel):
    parking: Annotated[float, Field(description='Parking time.')]
    type: Literal['multiplier']
    value: Annotated[
        float, Field(description="Multiplier value applied to original job's duration.")
    ]


class VicinityServingPolicy3(BaseModel):
    parking: Annotated[float, Field(description='Parking time.')]
    type: Literal['fixed']
    value: Annotated[
        float, Field(description='Fixed value used for all jobs in the cluster.')
    ]


class VicinityServingPolicy(
    RootModel[
        Union[VicinityServingPolicy1, VicinityServingPolicy2, VicinityServingPolicy3]
    ]
):
    root: Annotated[
        Union[VicinityServingPolicy1, VicinityServingPolicy2, VicinityServingPolicy3],
        Field(description='Specifies service time policy.'),
    ]


class VicinityThresholdPolicy(BaseModel):
    distance: Annotated[float, Field(description='Moving distance limit.')]
    duration: Annotated[float, Field(description='Moving duration limit.')]
    maxJobsPerCluster: Annotated[
        Optional[int],
        Field(description='The maximum amount of jobs per cluster.', ge=0),
    ] = None
    minSharedTime: Annotated[
        Optional[float],
        Field(description='Minimum shared time for jobs (non-inclusive).'),
    ] = None
    smallestTimeWindow: Annotated[
        Optional[float],
        Field(
            description='The smallest time window of the cluster after service time shrinking.'
        ),
    ] = None


class VicinityVisitPolicy(RootModel[str]):
    root: Annotated[str, Field(description='Specifies cluster visiting policy.')]


class Clustering1(BaseModel):
    filtering: Annotated[
        Optional[VicinityFilteringPolicy],
        Field(description='Specifies filtering policy.'),
    ] = None
    profile: Annotated[
        VehicleProfile,
        Field(
            description='Specifies a vehicle profile used to calculate commute duration and distance between\nactivities in the single stop.'
        ),
    ]
    serving: Annotated[
        VicinityServingPolicy, Field(description='Specifies service time policy.')
    ]
    threshold: Annotated[
        VicinityThresholdPolicy, Field(description='Specifies threshold information.')
    ]
    type: Literal['vicinity']
    visiting: Annotated[
        VicinityVisitPolicy, Field(description='Specifies visiting policy.')
    ]


class Clustering(RootModel[Clustering1]):
    root: Annotated[Clustering1, Field(description='Specifies clustering algorithm.')]


class JobPlace(BaseModel):
    duration: Annotated[
        float, Field(description='A job place duration (service time).')
    ]
    location: Annotated[Location, Field(description='A job place location.')]
    tag: Annotated[
        Optional[str],
        Field(
            description='A tag which will be propagated back within corresponding activity in solution.\nYou can use it to identify used place in solution.'
        ),
    ] = None
    times: Annotated[
        Optional[List[List[str]]],
        Field(
            description='A list of job place time windows with time specified in RFC3339 format.'
        ),
    ] = None


class JobTask(BaseModel):
    demand: Annotated[Optional[List[int]], Field(description='Job place demand.')] = (
        None
    )
    order: Annotated[
        Optional[int],
        Field(description='An order, bigger value - later assignment in the route.'),
    ] = None
    places: Annotated[
        List[JobPlace],
        Field(
            description='A list of possible places where given task can be performed.'
        ),
    ]


class Relation(BaseModel):
    jobs: Annotated[List[str], Field(description='List of job ids.')]
    shiftIndex: Annotated[
        Optional[int], Field(description='Vehicle shift index.', ge=0)
    ] = None
    type: Annotated[RelationType, Field(description='Relation type.')]
    vehicleId: Annotated[str, Field(description='Vehicle id.')]


class VehicleBreak1(BaseModel):
    places: Annotated[
        List[VehicleOptionalBreakPlace], Field(description='Vehicle break places.')
    ]
    policy: Annotated[
        Optional[VehicleOptionalBreakPolicy],
        Field(description='Specifies vehicle break policy.'),
    ] = None
    time: Annotated[VehicleOptionalBreakTime, Field(description='Break time.')]


class VehicleBreak2(BaseModel):
    duration: Annotated[float, Field(description='Break duration.')]
    time: Annotated[VehicleRequiredBreakTime, Field(description='Break time.')]


class VehicleBreak(RootModel[Union[VehicleBreak1, VehicleBreak2]]):
    root: Annotated[
        Union[VehicleBreak1, VehicleBreak2],
        Field(description='Specifies a vehicle break.'),
    ]


class VehicleRecharges(BaseModel):
    maxDistance: Annotated[
        float,
        Field(
            description='Maximum traveled distance before recharge station has to be visited.'
        ),
    ]
    stations: Annotated[
        List[JobPlace],
        Field(
            description='Specifies list of recharge station. Each can be visited only once.'
        ),
    ]


class VehicleShift(BaseModel):
    breaks: Annotated[
        Optional[List[VehicleBreak]], Field(description='Vehicle breaks.')
    ] = None
    end: Annotated[Optional[ShiftEnd], Field(description='Vehicle shift end.')] = None
    recharges: Annotated[
        Optional[VehicleRecharges],
        Field(description='Vehicle recharge stations information.'),
    ] = None
    reloads: Annotated[
        Optional[List[VehicleReload]],
        Field(
            description='Vehicle reloads which allows vehicle to visit place where goods can be loaded or\nunloaded during single tour.'
        ),
    ] = None
    start: Annotated[ShiftStart, Field(description='Vehicle shift start.')]


class VehicleType(BaseModel):
    capacity: Annotated[List[int], Field(description='Vehicle capacity.')]
    costs: Annotated[VehicleCosts, Field(description='Vehicle costs.')]
    limits: Annotated[Optional[VehicleLimits], Field(description='Vehicle limits.')] = (
        None
    )
    profile: Annotated[VehicleProfile, Field(description='Vehicle profile.')]
    shifts: Annotated[List[VehicleShift], Field(description='Vehicle shifts.')]
    skills: Annotated[Optional[List[str]], Field(description='Vehicle skills.')] = None
    typeId: Annotated[str, Field(description='Vehicle type id.')]
    vehicleIds: Annotated[List[str], Field(description='Concrete vehicle ids.')]


class Fleet(BaseModel):
    profiles: Annotated[List[MatrixProfile], Field(description='Routing profiles.')]
    resources: Annotated[
        Optional[List[VehicleResource]],
        Field(description='Specifies vehicle resources.'),
    ] = None
    vehicles: Annotated[List[VehicleType], Field(description='Vehicle types.')]


class Job(BaseModel):
    compatibility: Annotated[
        Optional[str],
        Field(
            description='A compatibility group: jobs with different compatibility cannot be assigned to the same tour.'
        ),
    ] = None
    deliveries: Annotated[
        Optional[List[JobTask]], Field(description='A list of delivery tasks.')
    ] = None
    group: Annotated[
        Optional[str],
        Field(
            description='Job group: jobs of the same group are assigned to the same tour or unassigned.'
        ),
    ] = None
    id: Annotated[str, Field(description='A job id.')]
    pickups: Annotated[
        Optional[List[JobTask]], Field(description='A list of pickup tasks.')
    ] = None
    replacements: Annotated[
        Optional[List[JobTask]], Field(description='A list of replacement tasks.')
    ] = None
    services: Annotated[
        Optional[List[JobTask]], Field(description='A list of service tasks.')
    ] = None
    skills: Annotated[
        Optional[JobSkills],
        Field(description='A job skills limitations for serving a job.'),
    ] = None
    value: Annotated[
        Optional[float],
        Field(description='Job value, bigger value - more chances for assignment.'),
    ] = None


class Plan(BaseModel):
    clustering: Annotated[
        Optional[Clustering], Field(description='Specifies clustering parameters.')
    ] = None
    jobs: Annotated[List[Job], Field(description='List of jobs.')]
    relations: Annotated[
        Optional[List[Relation]],
        Field(description='List of relations between jobs and vehicles.'),
    ] = None


class Problem(BaseModel):
    fleet: Annotated[
        Fleet,
        Field(description='Problem resources: vehicles to be used, routing info.'),
    ]
    objectives: Annotated[
        Optional[List[Objective]],
        Field(description='Specifies objective functions in lexicographical order.'),
    ] = None
    plan: Annotated[Plan, Field(description='Problem plan: customers to serve.')]


class Objective17(BaseModel):
    objectives: Annotated[
        List[Objective],
        Field(
            description='Competitive objectives except `Composite` type (nesting is currently not supported).'
        ),
    ]
    strategy: Annotated[
        MultiStrategy, Field(description='An objective composition type.')
    ]
    type: Literal['multi-objective']


class Objective(
    RootModel[
        Union[
            Objective1,
            Objective2,
            Objective3,
            Objective4,
            Objective5,
            Objective6,
            Objective7,
            Objective8,
            Objective9,
            Objective10,
            Objective11,
            Objective12,
            Objective13,
            Objective14,
            Objective15,
            Objective16,
            Objective17,
        ]
    ]
):
    root: Annotated[
        Union[
            Objective1,
            Objective2,
            Objective3,
            Objective4,
            Objective5,
            Objective6,
            Objective7,
            Objective8,
            Objective9,
            Objective10,
            Objective11,
            Objective12,
            Objective13,
            Objective14,
            Objective15,
            Objective16,
            Objective17,
        ],
        Field(description='Specifies objective function types.'),
    ]


Problem.model_rebuild()
Objective17.model_rebuild()
